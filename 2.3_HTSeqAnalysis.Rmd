---
title: "AE_RNAseq"
author: "Amanda Charbonneau"
date: '`r Sys.time()`'
output:
  html_document:
    code_folding: hide
    collapsed: no
    df_print: paged
    number_sections: yes
    theme: cerulean
    toc: yes
    toc_depth: 5
    toc_float: yes
  html_notebook:
    toc: yes
    toc_depth: 5
---

#Global parameters for modeling

```{r GlobalVariables}

#Setting a reasonable p-value threshold to be used throughout
p.threshold <- 0.05


#Reference level is Low
```


```{r LoadPackages, echo=FALSE, results='hide', include=FALSE}

# Install function for packages    
packages<-function(x){
  x<-as.character(match.call()[[2]])
  if (!require(x,character.only=TRUE)){
    install.packages(pkgs=x,repos="http://cran.r-project.org")
    require(x,character.only=TRUE)
  }
}

bioconductors <- function(x){
    x<- as.character(match.call()[[2]])
    if (!require(x, character.only = TRUE)){
      source("https://bioconductor.org/biocLite.R")
      biocLite(pkgs=x)
      require(x, character.only = TRUE)
    }
}

packages(MASS)
packages(ggplot2)
packages(gtools)
packages(pheatmap)
packages(cowplot)
packages(RColorBrewer)
packages(dplyr)
packages(ggrepel)
bioconductors(DESeq2)

```


```{r Data, echo=FALSE}
sessionInfo()

#Import all of the count files from mapping AE reads to a single genome

## To run interactively, you need to load the inputfiles manually, 
## run the following two commented lines:

## Inputfiles <- read.csv("../metadata/HTanalysisInputForR.csv")
##Mapping <- "AT_2016_GS"

subgroup <- Inputfiles[ Inputfiles$Dataname == Mapping, ]

ALLTHEFILES <- list.files(file.path(subgroup$countsDir), pattern = "*.counts.txt")

meta <- read.csv("../metadata/metadata.csv")

row.names(meta) <- meta[,1]

```


```{r Merge Gene Counts, echo=FALSE, include=FALSE, results='hide'}


File_Num <- length(ALLTHEFILES)


# Make first dataset into starting dataframe
ALLTHEGENES <- read.csv(paste(subgroup$countsDir, "/", ALLTHEFILES[ 1 ], sep=""),
                        sep = "\t", header = F,
                        col.names = c("Genes", regmatches(ALLTHEFILES[ 1 ], regexec("[1-6]_2008[0-9]+_[0-9]_[A-Z]+[0-9]", ALLTHEFILES[ 1 ]))))

# Remove X from name of column 2
colnames(ALLTHEGENES) <- c("Genes", substring(colnames(ALLTHEGENES[2]),2))

row.names(ALLTHEGENES) <- ALLTHEGENES[,1]

# In a loop, read in each dataset, then merge it into the starting dataframe

for( X in c( 2:File_Num )){ #start at 2 because first dataset already in

  File_Search <- regexec("[1-6]_2008[0-9]+_[0-9]_[A-Z]+[0-9]", ALLTHEFILES[ X ])
  File_Name <- regmatches(ALLTHEFILES[ X ], File_Search)
  Temp_File <- read.csv(paste(subgroup$countsDir, "/", ALLTHEFILES[ X ], sep=""), sep = "\t", header = F)
  colnames(Temp_File) <- c("Genes", File_Name)
  ALLTHEGENES <- inner_join( ALLTHEGENES, Temp_File )

}

no_feature <- colSums(dplyr::filter(ALLTHEGENES, Genes == "__no_feature" |
                               Genes == "__ambiguous" |
                               Genes == "__too_low_aQual" |
                               Genes == "__not_aligned" |
                               Genes == "__alignment_not_unique" )[,-1])


ALLTHEGENES <- dplyr::filter(ALLTHEGENES, Genes != "__no_feature" &
                               Genes != "__ambiguous" &
                               Genes != "__too_low_aQual" &
                               Genes != "__not_aligned" &
                               Genes != "__alignment_not_unique" )


row.names(ALLTHEGENES) <- ALLTHEGENES[,1]

genecounts <- as.data.frame(colSums(ALLTHEGENES[2:(File_Num+1)]))
colnames(genecounts) <- "MappedReads"

if ( sum(no_feature) != 0 ) {
genecounts <- cbind(genecounts, t(no_feature)[1:35])
colnames(genecounts) <- c("MappedReads", "UnmappedReads")
}


write.csv(genecounts, paste(subgroup$outputfilenameCounts))

```


```{r modeling with DESeq2, echo=FALSE, results='hide', include=FALSE}

# DESeq2 uses the `expressionset` data format, so the data needs to be reformatted to fit:

raph.exprs <-  dplyr::select(ALLTHEGENES, contains("2008"))

raph.groups <- dplyr::select(meta, FlowCell, Date, SampleInFC, ExID, Location, Line, SampleInLine)

raph.groups$FlowCell <- factor(raph.groups$FlowCell)

raph.groups$Line <- relevel(raph.groups$Line, ref="Low")

raph.groups$LocationLine <- factor(paste(raph.groups$Location, raph.groups$Line, sep=""))

raph.meta <- data.frame( description=c( "Sequencing Flowcell", "Sequencing Date", "Sample number in flowcell", "Sample Name", "Growth location of selection line", "High or Low selection", "Sample number in selection line", "PsuedoInteraction") )

raph.est <- ExpressionSet( assayData=as.matrix(raph.exprs),
                           phenoData=new( "AnnotatedDataFrame",
                           data=raph.groups, varMetadata=raph.meta ))
```

```{r NoInteractionDESeq2, echo=FALSE, results='hide', include=FALSE}

# Create DESeq2 datasets
## One with no interactions
raph.DES <- DESeqDataSetFromMatrix(countData = exprs( raph.est ), colData = pData( raph.est ), design = ~ FlowCell + Location + Line )

raph.DES <- DESeq( raph.DES )

##Remove low count genes
#raph.DES <- estimateSizeFactors(raph.DES)
#nc <- counts(raph.DES, normalized=TRUE)
#filter <- rowSums(nc >= 10) >= 2
#raph.DES <- raph.DES[filter,]
```

```{r PseudoInteractions DESeq2, echo=FALSE, results='hide', include=FALSE}
## One with pseudointeractions

raphpseudo.DES <- DESeqDataSetFromMatrix(countData = exprs( raph.est ), colData = pData( raph.est ), design = ~ LocationLine + FlowCell )

raphpseudo.DES <- DESeq( raphpseudo.DES )

```

```{r Interaction DESeq2, echo=FALSE, results='hide', include=FALSE}
## One with real interactions
raphInt.DES <- DESeqDataSetFromMatrix(countData = exprs( raph.est ), colData = pData( raph.est ), design = ~ FlowCell + Line + Location:Line )

##Remove low count genes
#raphInt.DES <- estimateSizeFactors(raphInt.DES)
#nc <- counts(raphInt.DES, normalized=TRUE)
#filter <- rowSums(nc >= 10) >= 2
#raphInt.DES <- raphInt.DES[filter,]

raphInt.DES  <- DESeq( raphInt.DES )


raphIntTestLRT.DES  <- DESeq( raphInt.DES, test="LRT", reduced=~FlowCell + Line)

#raphInt.DES <- estimateSizeFactors(raphInt.DES)
#raphInt.DES <- estimateDispersions(raphInt.DES)
#raphInt.DES <- nbinomWaldTest(raphInt.DES, maxit=500)

```


```{r HighLow contrasts with DESeq2, echo=FALSE, results='hide', include=FALSE}

## DESeq2 - High vs Low, NO interaction
## contrast=c(column, numerator, denominator)

results_hvl <- results( raph.DES, contrast=c("Line", "High", "Low"),
                        cooksCutoff=FALSE, independentFiltering=TRUE,
                        addMLE=TRUE, pAdjustMethod="BH", alpha = p.threshold)

results_hvl$threshold <- as.logical( results_hvl$padj < p.threshold )

results_hvl <- results_hvl[order(results_hvl$padj),]   

summary(results_hvl, alpha= p.threshold)

## DESeq2 - High vs Low, with PSEUDO interaction
## contrast=c(column, numerator, denominator)

Presults_hRvhK <- results( raphpseudo.DES, contrast=c("LocationLine", "KBSHigh", "ReedHigh"), cooksCutoff=FALSE, independentFiltering=TRUE, addMLE=TRUE, pAdjustMethod="BH", alpha = p.threshold)

Presults_hKvlK <- results( raphpseudo.DES, contrast=c("LocationLine", "KBSHigh", "KBSLow"), cooksCutoff=FALSE, independentFiltering=TRUE, addMLE=TRUE, pAdjustMethod="BH", alpha = p.threshold)

Presults_lRvlK <- results( raphpseudo.DES, contrast=c("LocationLine", "KBSLow", "ReedLow"), cooksCutoff=FALSE, independentFiltering=TRUE, addMLE=TRUE, pAdjustMethod="BH", alpha = p.threshold)

Presults_hRvlR <- results( raphpseudo.DES, contrast=c("LocationLine", "ReedHigh", "ReedLow"), cooksCutoff=FALSE, independentFiltering=TRUE, addMLE=TRUE, pAdjustMethod="BH", alpha = p.threshold)

Presults_hRvlK <- results( raphpseudo.DES, contrast=c("LocationLine", "ReedHigh", "KBSLow"), cooksCutoff=FALSE, independentFiltering=TRUE, addMLE=TRUE, pAdjustMethod="BH", alpha = p.threshold)

Presults_hKvlR <- results( raphpseudo.DES, contrast=c("LocationLine", "KBSHigh", "ReedLow"), cooksCutoff=FALSE, independentFiltering=TRUE, addMLE=TRUE, pAdjustMethod="BH", alpha = p.threshold)

## DESeq2 - High vs Low, WITH interaction
## contrast=c(column, numerator, denominator)
Intresults_hvl <- results( raphInt.DES, contrast=c("Line", "High", "Low"),
                           cooksCutoff=FALSE, independentFiltering=TRUE,
                           pAdjustMethod="BH", alpha = p.threshold )
# addMLE=TRUE, Error in results(raphInt.DES, contrast = c("Line", "High", "Low"), cooksCutoff = FALSE, addMLE=TRUE is only for when a beta prior was used. otherwise, the log2 fold changes are already MLE

Intresults_hvl$threshold <- as.logical( Intresults_hvl$padj < p.threshold )

Intresults_hvl <- Intresults_hvl[order(Intresults_hvl$padj),]   

summary(Intresults_hvl, alpha= p.threshold)


raphIntTestLRTresults_hvl <- results( raphIntTestLRT.DES,
                                      contrast=c("Line", "High", "Low"),
                                      cooksCutoff=FALSE, independentFiltering=TRUE,
                                      pAdjustMethod="BH", alpha = p.threshold )

raphIntTestLRTresults_hvl$threshold <- as.logical( raphIntTestLRTresults_hvl$padj < p.threshold )
raphIntTestLRTresults_hvl <- raphIntTestLRTresults_hvl[order(raphIntTestLRTresults_hvl$padj),]   

summary(raphIntTestLRTresults_hvl, alpha= p.threshold)

```


```{r Reed/KBS contrasts with DESeq2, echo=FALSE, results='hide', include=FALSE}

## DESeq2 - Reed vs KBS, NO interaction
## contrast=c(column, numerator, denominator)

results_hvl <- results( raph.DES, contrast=c("Line", "High", "Low"),
                        cooksCutoff=FALSE, independentFiltering=TRUE,
                        addMLE=TRUE, pAdjustMethod="BH", alpha = p.threshold)

results_hvl$threshold <- as.logical( results_hvl$padj < p.threshold )

results_hvl <- results_hvl[order(results_hvl$padj),]   

summary(results_hvl, alpha= p.threshold)

## DESeq2 - High vs Low, with PSEUDO interaction
## contrast=c(column, numerator, denominator)

Presults_hRvhK <- results( raphpseudo.DES, contrast=c("LocationLine", "KBSHigh", "ReedHigh"), cooksCutoff=FALSE, independentFiltering=TRUE, addMLE=TRUE, pAdjustMethod="BH", alpha = p.threshold)

Presults_hKvlK <- results( raphpseudo.DES, contrast=c("LocationLine", "KBSHigh", "KBSLow"), cooksCutoff=FALSE, independentFiltering=TRUE, addMLE=TRUE, pAdjustMethod="BH", alpha = p.threshold)

Presults_lRvlK <- results( raphpseudo.DES, contrast=c("LocationLine", "KBSLow", "ReedLow"), cooksCutoff=FALSE, independentFiltering=TRUE, addMLE=TRUE, pAdjustMethod="BH", alpha = p.threshold)

Presults_hRvlR <- results( raphpseudo.DES, contrast=c("LocationLine", "ReedHigh", "ReedLow"), cooksCutoff=FALSE, independentFiltering=TRUE, addMLE=TRUE, pAdjustMethod="BH", alpha = p.threshold)

Presults_hRvlK <- results( raphpseudo.DES, contrast=c("LocationLine", "ReedHigh", "KBSLow"), cooksCutoff=FALSE, independentFiltering=TRUE, addMLE=TRUE, pAdjustMethod="BH", alpha = p.threshold)

Presults_hKvlR <- results( raphpseudo.DES, contrast=c("LocationLine", "KBSHigh", "ReedLow"), cooksCutoff=FALSE, independentFiltering=TRUE, addMLE=TRUE, pAdjustMethod="BH", alpha = p.threshold)

## DESeq2 - High vs Low, WITH interaction
## contrast=c(column, numerator, denominator)
Intresults_hvl <- results( raphInt.DES, contrast=c("Line", "High", "Low"),
                           cooksCutoff=FALSE, independentFiltering=TRUE,
                           pAdjustMethod="BH", alpha = p.threshold )
# addMLE=TRUE, Error in results(raphInt.DES, contrast = c("Line", "High", "Low"), cooksCutoff = FALSE, addMLE=TRUE is only for when a beta prior was used. otherwise, the log2 fold changes are already MLE

Intresults_hvl$threshold <- as.logical( Intresults_hvl$padj < p.threshold )

Intresults_hvl <- Intresults_hvl[order(Intresults_hvl$padj),]   

summary(Intresults_hvl, alpha= p.threshold)


raphIntTestLRTresults_hvl <- results( raphIntTestLRT.DES,
                                      contrast=c("Line", "High", "Low"),
                                      cooksCutoff=FALSE, independentFiltering=TRUE,
                                      pAdjustMethod="BH", alpha = p.threshold )

raphIntTestLRTresults_hvl$threshold <- as.logical( raphIntTestLRTresults_hvl$padj < p.threshold )
raphIntTestLRTresults_hvl <- raphIntTestLRTresults_hvl[order(raphIntTestLRTresults_hvl$padj),]   

summary(raphIntTestLRTresults_hvl, alpha= p.threshold)

```

#Expression Data

Some exploratory plots of un-modeled gene counts.

##All by All heatmap

In all the following heatmaps, samples/genes are clustered by Euclidian distance of variance stablizing transformed gene counts (this removed the dependance of variance on mean, and flattens out the variance across the dataset, which makes the heatmaps a little easier to read)

A heatmap of expression levels for all genes in all individuals shows that the overall expression is very similar across individuals

```{r PlainLineHeatmap, echo=FALSE, fig.path=paste("../figures/",subgroup$Dataname,"/", sep=""), fig.keep="last", fig.width=11}
select_all <- order(rowMeans(counts(raph.DES,normalized=TRUE)),decreasing=TRUE)

df <- as.data.frame(colData(raph.DES)[,c("Line","Location")])

vsd <- varianceStabilizingTransformation(raph.DES, blind=TRUE)

pheatmap(assay(vsd)[select_all,], cluster_rows=FALSE, show_rownames=FALSE, cluster_cols=FALSE, annotation_col=df)

```

##Top 500 heatmap
Heatmap of modeled expression levels of 500 most highly expressed genes in all individuals.

This unclustered graph shows that there are differences in expression among the more highly expressed genes, although there are no obvious broad patterns between High vs Low or Reed vs KBS.


```{r MiniPlainLineHeatmap, echo=FALSE, fig.path=paste("../figures/",subgroup$Dataname,"/", sep=""), fig.keep="last", fig.width=11}

select500 <- order(rowMeans(counts(raph.DES,normalized=TRUE)),decreasing=TRUE)[1:500]

pheatmap(assay(vsd)[select500,], cluster_rows=F, show_rownames=F, cluster_cols=F, annotation_col=df)

```

##Clustered Top 500 heatmap

Clustering that same heatmap does show some structure, however read counts seem to be much more correlated with Location than with Line. In particular, the upper left corner with a tight cluster of down-regulated genes is four plants from Reed, but has both phenotypes. We'll have to factor out Location in the model.

```{r MiniPlainClusterLineHeatmap, echo=FALSE, fig.path=paste("../figures/",subgroup$Dataname,"/", sep=""), fig.keep="last", fig.width=11}

pheatmap(assay(vsd)[select500,], cluster_rows=T, show_rownames=FALSE, cluster_cols=T, annotation_col=df, clustering_distance_rows="euclidean", clustering_distance_cols="euclidean")

```

##Clustered Top 500 heatmap with Flowcell

Adding FlowCell to the clustered heatmap has very little effect, i.e. there doesn't appear to be a lot of systematic expression level difference due to sequencing run. We could probably get away without FlowCell in the model if we need to lose parameters.

```{r MiniPlainClusterLineHeatmapFC, echo=FALSE, fig.path=paste("../figures/",subgroup$Dataname,"/", sep=""), fig.keep="last", fig.width=11}

dfFC <- as.data.frame(colData(raph.DES)[,c("Line","Location", "FlowCell")])

pheatmap(assay(vsd)[select500,], cluster_rows=T, show_rownames=FALSE, cluster_cols=T, annotation_col=dfFC, clustering_distance_rows="euclidean", clustering_distance_cols="euclidean")

```


##Sample vs Sample heatmap

This sample heatmap echos the gene heatmaps in that there is little Low vs High structure to cluster out individuals by, and a relatively large effect of location.  This map is clustered, and although the clusters are not very strong, Reed and KBS clearly seperate.

```{r PlainSampleHeatmap, echo=FALSE, fig.path=paste("../figures/",subgroup$Dataname,"/", sep=""), fig.keep="last", fig.width=11}

sampleDists <- dist(t(assay(vsd)))
sampleDistMatrix <- as.matrix(sampleDists)
rownames(sampleDistMatrix) <- paste(vsd$Line, vsd$Location, sep="")
colnames(sampleDistMatrix) <- NULL
colors <- colorRampPalette( rev(brewer.pal(9, "Blues")) )(255)
pheatmap(sampleDistMatrix,
         clustering_distance_rows="euclidean",
         clustering_distance_cols="euclidean",
         cluster_rows = T,
         cluster_cols = T,
         col=colors)

```

##Sample vs Sample PCA

First two components of a PCA of the same normalized distance matrix used in the previous heatmap. These two vectors capture nearly 40% of the variance, but this seems to be mostly capturing Reed/KBS.

```{r plainPCA, echo=FALSE, fig.path=paste("../figures/",subgroup$Dataname,"/", sep=""), fig.keep="last", fig.width=11}
vsd_df <- as.data.frame(assay(vsd)[select_all,])


cowplot::plot_grid( plotPCA(vsd, intgroup="Location"),
                    plotPCA(vsd, intgroup="Line"),
                    plotPCA(vsd, intgroup=c( "Location", "Line")),
                           align="c", ncol=2)

#pca_vsd <- prcomp( vsd_df )  #index here to remove 'not_featured'
#plot(pca_vsd$x[,1], pca_vsd$x[,2])

#pca_vsd_lab <- as.data.frame( t(pca_vsd$x )) %>%
                 # mutate(name=rownames(t(pca_vsd$x))) %>%
                 # inner_join( df )

#plot(pca_vsd$PC1, pca_vsd$PC2)


```


```{r lda, echo=FALSE, include=FALSE, eval=FALSE}
##Sample vs Sample linear discriminant analysis

Comparison of the first three dfs of the same same normalized distance matrix. This model found some variables that are collinear, which suggests that some gene expression profiles are predictive of other genes.

vsd_lda <- as.data.frame(t(as.data.frame(vsd_df)))

vsd_lda$name <- rownames(vsd_lda)

vsd_lda <- inner_join(vsd_lda, df)
# lda( as.matrix(vsd_lda[, 1:80523 ]) ~ Line + Location, data=vsd_lda )

vsd_lda_m <- lda( Line:Location ~ as.matrix(vsd_lda[, 1:27217 ]), data=vsd_lda )

str(vsd_lda_m)

```

```{r Plotlda, echo=FALSE, eval=FALSE, fig.path=paste("../figures/",subgroup$Dataname,"/", sep=""), fig.keep="last", fig.width=11}
plot(vsd_lda_m)
```


#DESeq2
We're using `DESeq2` to estimate differential gene expression between the high and low anther exertion lines. It estimates the dispersion of the data similarly to `edgeR`, but then normalises using 'shrinkage'; adjusting the estimate on a gene-by-gene basis by comparing the dispersion of each gene with the group-level dispersion.

We have `r length(colnames(ALLTHEGENES))-1` individuals, with reads aligned to `r length(ALLTHEGENES$Genes)` gene models.

##Modeling
`DESeq2` uses a modified design matrix that allows it do perform shrinkage analysis. This modification results in the intercept being the midpoint between the two predictors of interest, and makes the results table increasingly un-interpretable with increasing model complexity. Ideally, we would like to model expression as:

`~ Location:Line + FlowCell +  Line`

Where Line (High or Low) is the predictor of interest. Due to the experimental setup, FlowCell is perfectly confounded with the date of the sequencing run and accounts for differences due to sequencing runs. Location*Line accounts for any interactions between selection line and replicate (Reed vs KBS).

Unfortunatly, we cannot run this model *and* estimate Log2 fold change shrinkage. Essentially, the way `DESeq2` is written, the modified model matrix can't handle interaction terms. This is partially just a problem of interpretation, the model will acutally run, but the output is incomprehensible, but also mathmatical, as the model is now attempting to shrink the group mean estimates to zero rather than trying to shrink the estimated differences to zero. There are three possible solutions to this:

  1. Make a pseudo-interaction term to call directly
  2. Drop the interaction term
  3. Use the interaction term, and revert to standard model matrices

###Psuedo-interaction  
Option 1 is the preferred method of the `DESeq2` authors, but will take some extra processing for our dataset. If we make a new, four level factor that is ReedHigh, ReedLow, KBSHigh, KBSLow to look for interaction effects, and run the model:

`~ LocationLine + FlowCell`

Then we'll get gene lists for all four conditions. To get the high vs low genes, I'll have to take the intersection of ReedHigh vs ReedLow and KBSHigh vs KBSLow.

###Drop interaction
Option 2 may give reasonable results, we would lose the ability to find genes that have interaction effects that cancel each other out, however we should have increased ability to detect outliers because the shrinkage analysis will work as designed.

###Use interaction
Option 3 may also give reasonable results, however, we will lose Log2 fold shrinkage, so fold change will be over-estimated in some cases. However, this option would ensure that any interaction effects are modeled out of the final Line contrast, which may mean that we can find differentially expressed genes that would have otherwise been hidden by interactions.


##Results

###No Interaction, shrunken log2 fold change
Model:  

`~ FlowCell + Location + Line`  (no interaction term)

This model found `r sum(results_hvl$padj < p.threshold, na.rm = TRUE)` differentially expressed genes with a p value < .05

####Summary Information from model and graph of dispersion shrinkage
```{r PlainSummaryplots, echo=FALSE}
#Summary of modeled values that meet the specified adjusted p-value cutoff
summary( results_hvl, alpha=p.threshold)

# Plot dispersion estimates
plotDispEsts( raph.DES )
```

####Log2 fold change
Since this model doesn't have an interaction term, the log2 fold change estimates are shrunken, and we can compare the shrunken and unshrunken estimates. Here, as expected, the lowest estimates are pulled much closer to the midline of the graph for the shrunken values. However, the model doesn't seem to be over-shrinking, as there are still many signifigant (red) values, including some that fall outside the plot (triangles).

```{r MAplots, echo=FALSE}
plotMA( results_hvl, MLE=TRUE, main="unshrunken LFC", ylim=c(-3,3), alpha=p.threshold )

plotMA( results_hvl, MLE=FALSE, main="Shrunken LFC", ylim=c(-3,3), alpha=p.threshold  )

```

###Pseudo Interaction, shrunken log2 fold change
Model:  

`~ FlowCell + LocationLine`  (no interaction term)


####Summary Information from model and graph of dispersion shrinkage
KBS high vs KBS low, then Reed high vs Reed low
```{r PseudoSummaryplots, echo=FALSE}
#Summary of modeled values that meet the specified adjusted p-value cutoff
summary( Presults_hKvlK, alpha=p.threshold)
summary( Presults_hRvlR, alpha=p.threshold)

# Plot dispersion estimates
plotDispEsts( raphpseudo.DES )
```

####Log2 fold change
Since this model doesn't have an interaction term, the log2 fold change estimates are shrunken, and we can compare the shrunken and unshrunken estimates. These are just the results for KBS high vs KBS low.

```{r pseudoMAplots, echo=FALSE}
plotMA( Presults_hKvlK, MLE=TRUE, main="unshrunken LFC", ylim=c(-3,3), alpha=p.threshold )

plotMA( Presults_hKvlK, MLE=FALSE, main="Shrunken LFC", ylim=c(-3,3), alpha=p.threshold  )

```


##With Interaction, unshrunken log2 fold change

Model  ~ Location:Line + FlowCell + Line  (interaction term)

This model found `r sum(Intresults_hvl$padj < p.threshold, na.rm = TRUE)` differentially expressed genes with a p value < .05


```{r Intplots, echo=FALSE}
#Summary of modeled values that meet the specified adjusted p-value cutoff
summary( Intresults_hvl, alpha=p.threshold)

# Plot dispersion estimates
plotDispEsts( raphInt.DES )

```

###Log2 fold change
Since this model has an interaction term, the log2 fold change estimates are unshrunken. As expected, these estimates are quite large, especially in the genes with lower overall expression.

```{r IntMAplot, echo=FALSE}

#plotMA( Intresults_hvl, MLE=TRUE, main="unshrunken LFC", ylim=c(-3,3), alpha=p.threshold )

plotMA( Intresults_hvl, MLE=FALSE, main="Only available LFC", ylim=c(-3,3), alpha=p.threshold  )


```

## Gene Lists

All labeled genes have a basemean greater than 20, and a log2foldchange of greater than 2

Differentially expressed genes from the no interaction model, high vs low.

```{r PlainGeneList, echo=FALSE, results='hide', fig.path=paste("../figures/",subgroup$Dataname,"/", sep=""), fig.keep="last", fig.width=11}

results_hvl_df <- data.frame( results_hvl, MLE=T )
  results_hvl_df$gene_name <- row.names( results_hvl )
results_hvl_df$FC <- logratio2foldchange(results_hvl_df$log2FoldChange)

results_hvl_df <- filter(results_hvl_df, !is.na(padj))

results_hvl_df$ABlog2FoldChange <- abs(results_hvl_df$log2FoldChange)

write.csv( results_hvl_df, paste(subgroup$outputfilenamePlain), quote=FALSE, row.names=FALSE)

ggplot(results_hvl_df, aes(log2FoldChange, baseMean, label=gene_name)) +
    geom_text_repel(data=filter( results_hvl_df, baseMean > 20 & log2FoldChange > 2), aes(col=padj)) +
    geom_point(aes(col=padj)) +
    labs(title = "High vs Low", x="Log 2 Fold Change", y="Base Mean")


```

Differentially expressed genes from the pseudo interaction model, for high vs low.


```{r PseudoGeneListHvL, echo=FALSE, results='hide'}

#Get both HvL

Presults_hRvlR_df <- data.frame( Presults_hRvlR, MLE=T )

Presults_hRvlR_df$gene_name <- row.names( Presults_hRvlR )

Presults_hKvlK_df <- data.frame( Presults_hKvlK, MLE=T )

Presults_hKvlK_df$gene_name <- row.names( Presults_hKvlK )

#Insert new columns and filter

Presults_hRvlR_df <- filter(Presults_hRvlR_df, !is.na(padj))
Presults_hKvlK_df <- filter(Presults_hKvlK_df, !is.na(padj))

Presults_hRvlR_df$FC <- logratio2foldchange(Presults_hRvlR_df$log2FoldChange)
Presults_hKvlK_df$FC <- logratio2foldchange(Presults_hKvlK_df$log2FoldChange)

Presults_hRvlR_df$ABlog2FoldChange <- abs(Presults_hRvlR_df$log2FoldChange)
Presults_hKvlK_df$ABlog2FoldChange <- abs(Presults_hKvlK_df$log2FoldChange)


#Get intersection of hvl
Presults_hvl_df <- inner_join(Presults_hRvlR_df, Presults_hKvlK_df, by=c("gene_name" = "gene_name"))

Presults_hvl_df <- mutate(Presults_hvl_df, AB_BM_Reed=ABlog2FoldChange.x*baseMean.x, AB_BM_KBS=ABlog2FoldChange.y*baseMean.y, diffL2FC=abs( ABlog2FoldChange.x - ABlog2FoldChange.y ) )

colnames(Presults_hvl_df) <- c("baseMean_Reed","log2FoldChange_Reed","lfcMLE_Reed","lfcSE_Reed",
      "stat_Reed","pvalue_Reed","padj_Reed","MLE_Reed","gene_name",
      "FC_Reed","ABlog2FoldChange_Reed","baseMean_KBS","log2FoldChange_KBS",
      "lfcMLE_KBS","lfcSE_KBS","stat_KBS","pvalue_KBS","padj_KBS",
      "MLE_KBS","FC_KBS","ABlog2FoldChange_KBS","AB_BM_Reed","AB_BM_KBS",
      "diffL2FC")

write.csv( Presults_hvl_df, paste(subgroup$outputfilenamePseudoHvL), quote=FALSE, row.names=FALSE)




```

```{r HighvLowReed, echo=FALSE, fig.path=paste("../figures/",subgroup$Dataname,"/", sep=""), fig.keep="last", fig.width=11}
ggplot(Presults_hvl_df, aes(log2FoldChange_Reed, baseMean_Reed, label=gene_name)) +
    geom_text_repel(data=filter( Presults_hvl_df, baseMean_Reed > 20 & log2FoldChange_Reed > 2 ), aes(col=padj_Reed)) +
    geom_point(aes(col=padj_Reed)) +
    labs(title = "High vs Low Reed", x="Log 2 Fold Change", y="Base Mean")

```

```{r HighvLowKBS, echo=FALSE, fig.path=paste("../figures/",subgroup$Dataname,"/", sep=""), fig.keep="last", fig.width=11}
ggplot(Presults_hvl_df, aes(log2FoldChange_KBS, baseMean_KBS, label=gene_name)) +
    geom_text_repel(data=filter( Presults_hvl_df, baseMean_KBS > 20 & log2FoldChange_KBS > 2), aes(col=padj_KBS)) +
    geom_point(aes(col=padj_KBS)) +
    labs(title = "High vs Low KBS", x="Log 2 Fold Change", y="Base Mean")

```


```{r PseudoGeneListRvK, echo=FALSE, results='hide'}

#Get both RvK

Presults_hRvhK_df <- data.frame( Presults_hRvhK, MLE=T )

Presults_hRvhK_df$gene_name <- row.names( Presults_hRvhK )

Presults_lRvlK_df <- data.frame( Presults_lRvlK, MLE=T )

Presults_lRvlK_df$gene_name <- row.names( Presults_lRvlK )

#Insert new columns and filter

Presults_hRvhK_df <- filter(Presults_hRvhK_df, !is.na(log2FoldChange))
Presults_lRvlK_df <- filter(Presults_lRvlK_df, !is.na(log2FoldChange))

Presults_hRvhK_df$FC <- logratio2foldchange(Presults_hRvhK_df$log2FoldChange)
Presults_lRvlK_df$FC <- logratio2foldchange(Presults_lRvlK_df$log2FoldChange)

Presults_hRvhK_df$ABlog2FoldChange <- abs(Presults_hRvhK_df$log2FoldChange)
Presults_lRvlK_df$ABlog2FoldChange <- abs(Presults_lRvlK_df$log2FoldChange)


#Get intersection of hvl
Presults_RvK_df <- inner_join(Presults_hRvhK_df, Presults_lRvlK_df, by=c("gene_name" = "gene_name"))

Presults_RvK_df <- mutate(Presults_RvK_df, AB_BM_High=ABlog2FoldChange.x*baseMean.x, AB_BM_Low=ABlog2FoldChange.y*baseMean.y, diffL2FC=abs( ABlog2FoldChange.x - ABlog2FoldChange.y ) )

write.csv( Presults_RvK_df, paste(subgroup$outputfilenamePseudoKvR), quote=FALSE, row.names=FALSE)

#plot_grid(
#ggplot(Presults_RvK_df, aes(log2FoldChange.x, baseMean.x, label=gene_name)) +
#    geom_text_repel(data=filter( Presults_RvK_df, baseMean.y > 4500 | abs(log2FoldChange.y) > 2.5 ), #aes(col=padj.x)) +
#    geom_point(aes(col=padj.y)) +
#    labs(title = "Reed High vs KBS High", x="Log 2 Fold Change", y="Base Mean") ,
#
#ggplot(Presults_RvK_df, aes(log2FoldChange.y, baseMean.y, label=gene_name)) +
#    geom_text_repel(data=filter( Presults_hvl_df, baseMean.x > 4500 | abs(log2FoldChange.x) > 2.5), #aes(col=padj.y)) +
#    geom_point(aes(col=padj.y)) +
#    labs(title = "Reed Low vs KBS Low", x="Log 2 Fold Change", y="Base Mean"))


```

Differentially expressed genes from the interaction model, high vs low.

```{r IntGeneList, echo=FALSE, results='hide'}

Intresults_hvl_df <- data.frame( Intresults_hvl )
Intresults_hvl_df$gene_name <- row.names( Intresults_hvl )

Intresults_hvl_df$FC <- logratio2foldchange(Intresults_hvl_df$log2FoldChange)

Intresults_hvl_df <- filter(Intresults_hvl_df, !is.na(padj))

Intresults_hvl_df$ABlog2FoldChange <- abs(Intresults_hvl_df$log2FoldChange)

write.csv( Intresults_hvl_df, paste(subgroup$outputfilenameInteraction), quote=FALSE, row.names=FALSE )

ggplot(Intresults_hvl_df, aes(log2FoldChange, baseMean, label=gene_name)) +
    geom_text_repel(data=filter( Intresults_hvl_df, baseMean > 20 & log2FoldChange > 2), aes(col=padj)) +
    geom_point(aes(col=padj)) +
    labs(title = "Interaction: High vs Low", x="Log 2 Fold Change", y="Base Mean")

raphIntTestLRTresults_hvl_df <- data.frame( raphIntTestLRTresults_hvl )
raphIntTestLRTresults_hvl_df$gene_name <- row.names( raphIntTestLRTresults_hvl )
raphIntTestLRTresults_hvl_df$FC <- logratio2foldchange(raphIntTestLRTresults_hvl_df$log2FoldChange)
raphIntTestLRTresults_hvl_df$ABlog2FoldChange <- abs(raphIntTestLRTresults_hvl$log2FoldChange)
raphIntTestLRTresults_hvl_df <- filter(raphIntTestLRTresults_hvl_df, !is.na(padj)) %>%
                    filter( threshold==TRUE)

write.csv( raphIntTestLRTresults_hvl_df, paste(subgroup$outputfilenameLRTinteraction), quote=FALSE, row.names=FALSE )

```




```{r MeanExpressionPlots, eval=FALSE, echo=FALSE}
par(mfrow=c(2,1))
plot(y = log2(results_hvl$baseMean), x =(log2(results_hvl$baseMean) - results_hvl$log2FoldChange ),
    ylab = "mean expression low", xlab = "mean expression high",
    main = "Anther Exertion", pch = 20, col ="grey")
with(results_hvl_df[results_hvl_df$padj <0.05, ],
    points(y = log2(baseMean),x =(log2(baseMean) - log2FoldChange ),
    pch=20, col = "black" ))  
abline(a=0, b=1 , col="blue")

plot(y = results_hvl$log2FoldChange, x =log2(results_hvl$baseMean) ,
    ylab = "log2 fold change (L/H)", xlab = "mean expression low",
    main = " MAplot selection differences in AE", pch = 20, col ="grey")
with(results_hvl_df[results_hvl_df$padj <0.05, ],
    points(y = log2FoldChange,x = log2(baseMean),
    pch=20, col = "black" ))  
abline(a=0, b=0 , col="blue")
```

Comparison of top 10 highest adjusted p-value genes from "No interaction" model:
```{r, echo=FALSE}
dplyr::select(results_hvl_df, gene_name, log2FoldChange, padj) %>% arrange(padj) %>% head(n=10)

```

pseudo interaction model:

```{r, echo=FALSE}

dplyr::select(Intresults_hvl_df, gene_name, log2FoldChange, padj) %>% arrange(padj) %>% head(n=10)

```

and interaction model:

```{r, echo=FALSE}

dplyr::select(Presults_hvl_df, gene_name, log2FoldChange_Reed, padj_Reed) %>% arrange(padj_Reed) %>% head( n=10 )


```


```{r TopPvalue, eval=FALSE, echo=FALSE}
####Example count plot, highly signifigant genes

par(mfrow=c(2,2))

for( names in row.names(results_hvl[order(results_hvl$padj),][1:4,])){
plotCounts(raph.DES, gene= names, intgroup="Line", col=raph.DES$Location)
}
```


```{r TopFC, eval=FALSE, echo=FALSE}
####Example count plot, highly different genes

par(mfrow=c(2,2))

for( names in row.names(results_hvl[order(results_hvl$log2FoldChange),][1:4,])){
plotCounts(raph.DES, gene= names, intgroup="Line", col=raph.DES$Location)
}
```


```{r testing, eval=FALSE, echo=FALSE}

deseq2_results_rvk <- results( raph.DES, contrast=list( "LocationReed", "LocationKBS" ), cooksCutoff=FALSE, independentFiltering=TRUE, )

deseq2_results_hvl$threshold <- as.logical( deseq2_results_hvl$padj < p.threshold )
    deseq2_genes_hvl <- row.names( deseq2_results_hvl )[ which( deseq2_results_hvl$threshold )]



deseq2_results_rvk_df <- data.frame( deseq2_results_rvk )
  deseq2_results_rvk_df$gene_name <- row.names( deseq2_results_rvk )
deseq2_results_rvk_df$FC <- logratio2foldchange(deseq2_results_rvk_df$log2FoldChange)

deseq2_results_rvk_df <- filter(deseq2_results_rvk_df, !is.na(log2FoldChange))

deseq2_results_rvk_df$ABlog2FoldChange <- abs(deseq2_results_rvk_df$log2FoldChange)

write.csv( deseq2_results_rvk_df, paste(subgroup$outputfilename), quote=FALSE, row.names=FALSE )

```

#Genome Comparisons

It's important to note that although Kitashiba2014 covers more of the actual genome and has a much better N50 than the others, it still has a ridiculous number of contigs. All of these genomes are so fragmented that even the 'best' one still isn't good.

```{r Upcoming, echo=FALSE}
Measure<- c("# contigs", "N50", "Assembled_length (Mb)","gene models", "Annotations")
Moghe2014 <- c(64732,10186,253,50974, "No")
Kitashiba2014 <- c(76592,46262,402,80521, "No")
Mitsui2015 <- c(72909,7120,384,64657, "Yes")
Jeong2016 <- c(38732,19600,371.6,46514, "Yes")



as.data.frame(cbind(Measure,Moghe2014,Kitashiba2014,Mitsui2015,Jeong2016))
```
